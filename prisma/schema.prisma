// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Transaction {
  id        Int      @id @default(autoincrement())
  text      String
  amount    Float
  category  String
  date      String   // ISO YYYY-MM-DD
  month     String   // YYYY-MM
  accountId String?
  userId    String
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  account   Account? @relation(fields: [accountId], references: [id], onDelete: SetNull) // Create SetNull to avoid deleting transactions if account is deleted? Or Cascade? Let's stick to Cascade or SetNull. detailed plan said Cascade usually. Let's stick to original behavior for account but added user.
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Account {
  id        String   @id @default(cuid())
  name      String
  type      String
  balance   Float
  currency  String   @default("EUR")
  color     String   @default("#000000")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  transactions Transaction[]
}

model RecurringTransaction {
  id           String   @id @default(cuid())
  text         String
  amount       Float
  category     String
  interval     String   @default("monthly")
  dayOfMonth   Int
  startDate    String
  endDate      String?
  lastExecuted String?
  isActive     Boolean  @default(true)
  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

model Category {
  key         String   @id
  label       String
  color       String
  budgetLimit Float?
  userId      String?
  user        User?   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([key, userId]) // Allow same category key for different users, or global categories? Let's make it simple for now, maybe just add userId.
}

model Settings {
  id            Int     @id @default(1)
  currency      String  @default("EUR")
  theme         String  @default("dark")
  notifications Boolean @default(true)
  budgetLimit   Float   @default(0)
  userId        String  @unique // One settings per user
  user          User    @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Sparkasse {
  id               Int     @id @default(autoincrement())
  userId           String  @unique
  user             User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  balance          Float   @default(0)
  goal             Float   @default(0)
  monthlyDeposited Float   @default(0)
  autoSaveAmount   Float   @default(0)
  autoSaveEnabled  Boolean @default(false)
  autoSaveDay      Int     @default(1)
}

model AccountType {
    id    String @id
    label String
    emoji String
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  password      String?
  role          String  @default("USER") // "ADMIN" or "USER"
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  accounts              Account[]
  transactions          Transaction[]
  recurringTransactions RecurringTransaction[]
  settings              Settings?
  sparkasse             Sparkasse?
  categories            Category[]
}
